MapCmds.Nominate = MapCmds.Nominate or {}local Nominate = MapCmds.NominateNominate.MapList = {}Nominate.PlayerNominations = {}Nominate.NominatedMaps = {} -- a set of nominated maps (mapnames are the keys)Nominate.NominatedMapCount = 0local MapList = Nominate.MapListlocal PlayerNominations = Nominate.PlayerNominationslocal NominatedMaps = Nominate.NominatedMapslocal ExcludeOld = CreateConVar ("sm_nominate_excludeold", "1", FCVAR_NONE, "Specifies if the current map should be excluded from the Nominations list")local ExcludeCurrent = CreateConVar ("sm_nominate_excludecurrent", "1", FCVAR_NONE, "Specifies if the MapChooser excluded maps should also be excluded from Nominations")MapCmds.IncludeMaps = CreateConVar ("sm_mapvote_include", "5", FCVAR_NONE, "Specifies how many maps to include in the vote.")local STATUS_ENABLED = 1local STATUS_DISABLED = 2local STATUS_EXCLUDE_CURRENT = 4local STATUS_EXCLUDE_PREVIOUS = 8local STATUS_EXCLUDE_NOMINATED = 16local NOMINATE_ADDED = 1local NOMINATE_INVALIDMAP = 2local NOMINATE_REPLACED = 3local NOMINATE_VOTEFULL = 4local NOMINATE_ALREADYINVOTE = 5local Menu = nil--[[for _, v in ipairs (file.Find ("maps/*.bsp", "GAME")) do	MapList [v:lower ():sub (1, v:len () - 4)] = STATUS_ENABLEDend]]for _, v in ipairs (MapCmds.NextMaps) do	MapList [v:lower ()] = STATUS_ENABLEDendfunction Nominate.AttemptNominate (ply)	Menu:Show (ply)endfunction Nominate.BuildMapMenu ()	Menu = MapCmds.CreateMenu ()	Nominate.Menu = Menu	Menu:SetTitle ("Nominate Map:")		local currentMap = game.GetMap ():lower ()	local menuItems = {}	for k, _ in pairs (MapList) do		local status = STATUS_ENABLED				if ExcludeCurrent:GetBool () then			if k == currentMap then				status = STATUS_DISABLED + STATUS_EXCLUDE_CURRENT			end		end				if ExcludeOld:GetBool () and status == STATUS_ENABLED then					end				menuItems [#menuItems + 1] = k	end		table.sort (menuItems)	for _, v in ipairs (menuItems) do		Menu:AddItem (v, v)	end		Menu:SetCallback (function (ply, id)		local result = Nominate.NominateMap (id, false, ply)		if result == NOMINATE_ALREADYINVOTE then			MapCmds.PrintToPlayer (ply, "The map you chose has already been nominated.")			return		elseif result == NOMINATE_VOTEFULL then			MapCmds.PrintToPlayer (ply, "The maximum allowed nominations has been reached.")			return		end				MapList [id] = STATUS_DISABLED + STATUS_EXCLUDE_NOMINATED				if result == NOMINATE_REPLACED then			MapCmds.PrintToAll (ply:Name () .. " has changed his nomination to " .. id .. ".")			return		end				MapCmds.PrintToAll (ply:Name () .. " has nominated " .. id .. ".")	end)endNominate.BuildMapMenu ()function Nominate.ClearNominations ()	Nominate.NominatedMaps = {}	Nominate.NominatedMapCount = 0	Nominate.PlayerNominations = {}endfunction Nominate.FindMap (partialName)	partialName = partialName:lower ()	for k, _ in pairs (MapList) do		if k:lower ():find (partialName, 1, true) then			return k		end	end	return nilendfunction Nominate.NominateMap (map, force, owner)	if not MapList [map] then return NOMINATE_INVALIDMAP end		if NominatedMaps [map] then return NOMINATE_ALREADYINVOTE end		if owner and PlayerNominations [owner] then		--NominatedMaps [PlayerNominations [owner]] = nil		PlayerNominations [owner] = map		NominatedMaps [PlayerNominations [owner]] = true		return NOMINATE_REPLACED	end		if Nominate.NominatedMapCount >= MapCmds.IncludeMaps:GetInt () and not force then		return NOMINATE_VOTEFULL	end		NominatedMaps [map] = true	PlayerNominations [owner] = map	Nominate.NominatedMapCount = Nominate.NominatedMapCount + 1		return NOMINATE_ADDEDendlocal function TryNominatePartialMap (ply, partialName)	partialName = partialName or ""	local map = Nominate.FindMap (partialName)	if not map then		MapCmds.PrintToPlayer (ply, "Map " .. partialName .. " was not found.")		return	end		local status = Nominate.MapList [map]	if bit.band (status, STATUS_DISABLED) > 0 then		if bit.band (status, STATUS_EXCLUDE_CURRENT) > 0 then			MapCmds.PrintToPlayer (ply, "The map you chose is the current map and cannot be nominated.")		elseif bit.band (status, STATUS_EXCLUDE_PREVIOUS) > 0 then			MapCmds.PrintToPlayer (ply, "The map you chose was recently played and cannot be nominated.")		elseif bit.band (status, STATUS_EXCLUDE_NOMINATED) > 0 then			MapCmds.PrintToPlayer (ply, "The map you chose has already been nominated.")		end		return	end		local result = Nominate.NominateMap (map, false, ply)	if result > NOMINATE_REPLACED then		if result == NOMINATE_ALREADYINVOTE then			MapCmds.PrintToPlayer (ply, "Map '" .. map .. "' already in the nominations list.")		else			MapCmds.PrintToPlayer (ply, "The map you chose has already been nominated.")		end		return	end		Nominate.MapList [map] = STATUS_DISABLED + STATUS_EXCLUDE_NOMINATED		MapCmds.PrintToAll (ply:Name () .. " has nominated " .. map .. ".")end--interfacehook.Add ("PlayerSay", "MapCmds.Nominate", function (ply, text, team)	local firstChar = text:sub (1, 1)	if firstChar ~= "!" and firstChar ~= "/" then return end	local cmd = text:sub (2):Trim ():lower ()	local args = string.Explode (" ", cmd)	cmd = args [1]	table.remove (args, 1)	if cmd == "nominate" then		if #args == 0 then			Nominate.AttemptNominate (ply)			return ""		end				TryNominatePartialMap (ply, table.concat (args, " "))		return ""	endend)concommand.Add ("sm_nominate", function (ply, _, args)	if not ply or not ply:IsValid () then return end		if #args == 0 then		Nominate.AttemptNominate (ply)		return	end		TryNominatePartialMap (ply, table.concat (args, " "))end)hook.Add ("PlayerDisconnect", function (ply)	if PlayerNominations [ply] then		NominatedMaps [PlayerNominations [ply]] = nil		Nominate.NominatedMapCount = Nominate.NominatedMapCount - 1		PlayerNominations [ply] = nil	endend)